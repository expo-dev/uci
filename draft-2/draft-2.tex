\includeruby color.rb
\includeruby syntax.rb
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\XeTeXuseglyphmetrics=1
%
\def\ldfont     #1#2#3{"#1/S=#2:mapping=tex-text#3"          at #2 pt}%
\def\ldifont    #1#2#3{"#1/S=#2/I:mapping=tex-text#3"        at #2 pt}%
\def\ldbfont    #1#2#3{"#1/S=#2/B:mapping=tex-text#3"        at #2 pt}%
\def\ldbifont   #1#2#3{"#1/S=#2/BI:mapping=tex-text#3"       at #2 pt}%
\def\ldcapfont  #1#2#3{"#1/S=#2:mapping=tex-text:+smcp#3"    at #2 pt}%
\def\ldicapfont #1#2#3{"#1/S=#2/I:mapping=tex-text:+smcp#3"  at #2 pt}%
\def\ldbcapfont #1#2#3{"#1/S=#2/B:mapping=tex-text:+smcp#3"  at #2 pt}%
\def\ldbicapfont#1#2#3{"#1/S=#2/BI:mapping=tex-text:+smcp#3" at #2 pt}%
%
\def\basefamily{Alegreya Sans}%
\def\basesize{11}%
\def\basefeat{:+liga:+clig:+calt:+onum:+pnum}%
\font\rm  =\ldfont    {\basefamily}{\basesize}{\basefeat}%
\font\it  =\ldifont   {\basefamily}{\basesize}{\basefeat}%
\font\bf  =\ldbfont   {\basefamily}{\basesize}{\basefeat}%
\font\caps=\ldcapfont {\basefamily}{\basesize}{\basefeat}%
\font\icap=\ldicapfont{\basefamily}{\basesize}{\basefeat}%
%
\def\supfamily{Alegreya Sans Medium}%
\def\supsize{7.4}%
\def\supfeat{:+liga:+clig:+calt:+onum:+pnum}%
\font\suprm=\ldfont {\supfamily}{\supsize}{\supfeat}%
\font\supit=\ldifont{\supfamily}{\supsize}{\supfeat}%
%
\def\sup#1{\raise 0.73ex\hbox{\suprm #1}}%
\def\isup#1{\raise 0.73ex\hbox{\supit #1}}%
%
\def\subfamily{Alegreya Sans Medium}%
\def\subsize{7.4}%
\def\subfeat{:+liga:+clig:+calt:+onum:+pnum}%
\font\subrm=\ldfont {\subfamily}{\subsize}{\subfeat}%
\font\subit=\ldifont{\subfamily}{\subsize}{\subfeat}%
%
\def\sub#1{\lower 0.23ex\hbox{\subrm #1}}%
\def\isub#1{\lower 0.23ex\hbox{\subit #1}}%
%
\def\codefamily{JetBrains Mono}%
\def\codesize{9.25}%
\def\codefeat{:+liga:+clig:+calt:lnum:+tnum}%
%
\font\fw =\ldfont {\codefamily}{\codesize}{\codefeat}%
\font\ifw=\ldifont{\codefamily}{\codesize}{\codefeat}%
%
\def\fs{%
  \spaceskip=0.5em
  \xspaceskip=0.5em
}%
%
\font\noto    ="Noto Sans:mapping=tex-text"      at 10 pt
\font\notomono="Noto Sans Mono:mapping=tex-text" at 10 pt
%
\rm
\spaceskip =0.3em plus 0.15em minus 0.15em
\xspaceskip=0.5em plus 0.25em minus 0.25em
%
\def\lcap#1{%
  \font\localfont=\ldcapfont{\basefamily}{\basesize}{\basefeat:letterspace=#1}%
  \localfont
  \dimen0=0.0625\fontdimen2\localfont
  \multiply\dimen0 by #1
  \advance\dimen0 by \fontdimen2\localfont
  \spaceskip =   \dimen0 plus 0.5\dimen0 minus 0.5\dimen0
  \xspaceskip=1.5\dimen0 plus 0.5\dimen0 minus 0.5\dimen0
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newbox\testbox
\newcount\testem
\newcount\testwd
\def\setrpcode#1#2{%
  \setbox\testbox=\hbox{\char#2}%
  \testwd=\wd\testbox
  \multiply\testwd by 1000
  \divide\testwd by\testem
  \rpcode#1 U#2 \the\testwd
}%
\def\setlpcode#1#2{%
  \setbox\testbox=\hbox{\char#2}%
  \testwd=\wd\testbox
  \multiply\testwd by 1000
  \divide\testwd by\testem
  \lpcode#1 U#2 \the\testwd
}%
\def\setpcodes#1{%
  {#1%
    \setbox\testbox=\hbox{\kern1em}%
    \testem=\wd\testbox
    \setrpcode{#1}{"0021}% exclamation mark
    \setlpcode{#1}{"0027}% apostrophe
    \setlpcode{#1}{"0028}% left parenthesis
    \setrpcode{#1}{"0029}% right parenthesis
    \setrpcode{#1}{"002A}% asterisk
    \setrpcode{#1}{"002C}% comma
    \setrpcode{#1}{"002D}% hyphen
    \setrpcode{#1}{"002E}% full stop
    \setrpcode{#1}{"003B}% semicolon
    \setrpcode{#1}{"003A}% colon
    \setrpcode{#1}{"003F}% question mark
    \setlpcode{#1}{"005B}% left square bracket
    \setrpcode{#1}{"005D}% right square bracket
    \setlpcode{#1}{"2018}% left single quote
    \setrpcode{#1}{"2019}% right single quote
    \setlpcode{#1}{"201C}% left double quote
    \setrpcode{#1}{"201D}% right double quote
  }%
}%
\XeTeXprotrudechars=2
\setpcodes{\rm}%
\setpcodes{\it}%
\setpcodes{\bf}%
\setpcodes{\caps}%
\setpcodes{\icap}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\url#1#2{%
  \special{pdf:bann <<
    /Subtype /Link
    /A << % Action
      /S /URI % Subtype
      /URI (#1)
    >>
    /Border [ 0 0 0 ] % [ horiz corner radius, vert corner radius, width ]
    /C [ 1 0 0 ] % Color [ r, g, b ]
  >>}%
  #2\special{pdf:eann}%
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\qt{\kern -1.0pt}%
\def\ot{\kern  0.5pt}%
\def\pt{\kern  1.0pt}%
\def\dt{\kern  2.0pt}%
\def\fem{\hskip 0.200em}%
\def\qem{\hskip 0.250em}%
\def\tem{\hskip 0.333em}%
\def\hem{\hskip 0.500em}%
\def\em {\hskip 1.000em}%
\def\dem{\hskip 2.000em}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\beginruby
  pageW   = 210
  pageH   = 297
  marginL =  50
  marginR =  50
  marginT =  38.5
  marginB =  38.5
  hoffset = (marginL - 25.4).round(3)
  voffset = (marginT - 25.4).round(3)
  hsize   = (pageW - marginL - marginR).round(3)
  vsize   = (pageH - marginT - marginB).round(3)
\endruby
\pdfpagewidth\r{pageW}mm
\pdfpageheight=\r{pageH}mm
\hoffset=\r{hoffset}mm
\voffset=\r{voffset}mm
\hsize=\r{hsize}mm
\vsize=\r{vsize}mm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pretolerance=200
\tolerance=200
\baselineskip=16pt
\parskip=8pt
\parindent=0pt
\raggedbottom
\nopagenumbers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\beginruby
  # Color Boxes
    grey_bg = lch(0.96, 0.0  ,   0);   grey_rbn = lch(0.70, 0.0  ,   0)
     red_bg = lch(0.96, 0.018,  15);    red_rbn = lch(0.70, 0.18 ,  15)
  yellow_bg = lch(0.97, 0.018,  90); yellow_rbn = lch(0.85, 0.15 ,  90)
   green_bg = lch(0.96, 0.018, 145);  green_rbn = lch(0.75, 0.15 , 145)
    blue_bg = lch(0.96, 0.018, 270);   blue_rbn = lch(0.70, 0.15 , 270)
  purple_bg = lch(0.96, 0.018, 330); purple_rbn = lch(0.70, 0.15 , 330)

  # Body copy
     red_fg = lch(0.6, 0.2 ,  30  )
    teal_fg = lch(0.6, 0.1 , 180  )
  purple_fg = lch(0.5, 0.25, 292.5)
    grey_fg = lch(0.5, 0.0 ,   0  )
   label_fg = lch(0.6, 0.0 ,   0  )
  ltgrey_fg = lch(0.7, 0.0 ,   0  )

  # Pseudocode
  amber_fg = lch(0.7, 0.125,  75)
  green_fg = lch(0.6, 0.15 , 150)
   blue_fg = lch(0.5, 0.2  , 270)
  lilac_fg = lch(0.6, 0.2  , 300)
\endruby
%
\newtoks\restorecolor \restorecolor={0 0 0}%
%
\long\def\color#1#2{%
  {\restorecolor={#1}\special{color rgb #1}#2}%
  \special{color rgb \the\restorecolor}%
}%
%
\long\def\colorbox#1#2#3{%
  \par
  % Set the contents of the box
  \advance\hsize by -2em
  \setbox0 = \vbox{#3}%
  \advance\hsize by 2em
  % Insert the usual interline glue
  \ifdim \prevdepth > -1000pt
    \vskip-\prevdepth
    \vskip\baselineskip
  \fi
  % Insert an extra half of a baselineskip above
  \vskip0.5\baselineskip
  % Calculate dimensions
  \dimen0 = \ht0
  \dimen1 = \dp0
  \advance\dimen0 by 0.25\baselineskip % midway along half-baselineskip above
  \advance\dimen0 by 0.25\baselineskip % adjust the upper edge and
  \advance\dimen1 by 0.20\baselineskip %   lower edge to be perceptually correct
  \advance\dimen1 by 0.25\baselineskip % midway along half-baselineskip below
  % Insert the background
  \kern -0.25\baselineskip % midway along extra
  \kern -0.25\baselineskip % adjustment
  \color{#1}{\hrule width \hsize height \dimen0 depth \dimen1}%
  \kern -\ht0
  \kern -\dp0
  \kern -0.20\baselineskip % adjustment
  \kern -0.25\baselineskip % midway along extra
  % Insert the ribbon
  \kern -0.25\baselineskip % midway along extra
  \kern -0.25\baselineskip % adjustment
  \color{#2}{\hrule width 0.5em height \dimen0 depth \dimen1}%
  \kern -\ht0
  \kern -\dp0
  \kern -0.20\baselineskip % adjustment
  \kern -0.25\baselineskip % midway along extra
  % Insert the box
  \hbox{\hskip1em\box0}
  % Insert an extra half of a baselineskip below
  \vskip0.5\baselineskip
}%
\long\def  \greybox#1{\colorbox{\r{  grey_bg}}{\r{  grey_rbn}}{#1}}%
\long\def\purplebox#1{\colorbox{\r{purple_bg}}{\r{purple_rbn}}{#1}}%
\long\def  \bluebox#1{\colorbox{\r{  blue_bg}}{\r{  blue_rbn}}{#1}}%
\long\def \greenbox#1{\colorbox{\r{ green_bg}}{\r{ green_rbn}}{#1}}%
\long\def\yellowbox#1{\colorbox{\r{yellow_bg}}{\r{yellow_rbn}}{#1}}%
\long\def   \redbox#1{\colorbox{\r{   red_bg}}{\r{   red_rbn}}{#1}}%
%
\long\def\label  #1{\color{\r{ label_fg}}{#1}}%
\long\def\term   #1{\color{\r{purple_fg}}{#1}}%
\long\def\comment#1{\color{\r{  grey_fg}}{{\noto ※ }#1}}%
\long\def\s      #1{\color{\r{  teal_fg}}{\fw #1}}%
%
\def\hex#1{{\fw\color{\r{ltgrey_fg}}{x}#1}}%
\def\uni#1{{\caps u+#1}}%
%
\def\ellipsis{.\ot.\ot.}
%
\newcount\majorcount
\newcount\minorcount
\def\major{%
  \advance\majorcount by 1
  \minorcount=0
  \leavevmode
  \llap{\label{\the\majorcount}\hem}%
}%
\def\minor{%
  \advance\minorcount by 1
  \leavevmode
  \llap{\label{\the\majorcount·\the\minorcount}\hem}%
}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\gets{<-}%
\def\to  {->}%
\def\then{=>}%
%
\setbox0=\hbox{\fw ()[]\char"7B\char"7D\it ()[]\char"7B\char"7D}%
\newdimen\strutht
\newdimen\strutdp
\strutht=\ht0
\strutdp=\dp0
\dimen0=\baselineskip
\advance\dimen0 by -\strutht
\advance\dimen0 by -\strutdp
\divide\dimen0 by 2
\advance\strutht by \dimen0
\advance\strutdp by \dimen0
\def\strut{\vrule width 0pt height \strutht depth \strutdp}%
%
\def\tab{%
  \kern 0.75ex
  \color{\r{ltgrey_fg}}{\vrule width 0.5pt}%
  \kern -0.5pt
  \kern -0.75ex
  \kern 3ex
}%
%
\def\kwd  #1{\color{\r{  blue_fg}}{#1}}% def, return, break, error
\def\flow #1{\color{\r{ amber_fg}}{#1}}% repeat, if, then, match
\def\liter#1{\color{\r{   red_fg}}{#1}}% numeric
\def\const#1{\color{\r{ lilac_fg}}{#1}}% empty, eof
\def\func #1{\color{\r{ green_fg}}{#1}}%
\def\var  #1{{\ifw #1}}%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\vglue1\baselineskip
\centerline{\lcap8 UNIVERSAL CHESS INTERFACE}
\centerline{\lcap4 october 2024 • draft}

\vskip4\baselineskip

{\bf Introduction}

This specification governs the interaction between two processes named the
{\it client} and the {\it engine}. \comment{Graphical interfaces, terminal
emulators, and scripts and utilities are examples of clients.} The text of
sections 1–4 is normative (except as described in {\it Conventions} below).

{\bf Getting Started}

{\it This section needs to be written! It should contain enough for a beginner
to add basic {\icap uci} support to their engine.}

{\bf Conventions}

Sequences are written with angle brackets; for example, ⟨\ot0, 1, 2,
\ellipsis\pt⟩. An~{\fw\color{\r{ltgrey_fg}}{x}} preceding a number
indicates that it is written in hexadecimal; for example, \hex{10} = 16.
Sequences of bytes encoded in {\caps ascii} are set in teal; for example,
\s{uci} = ⟨\ot\hex{75}, \hex{63}, \hex{69}⟩\pt. Sequences of tokens may be
written without commas when they contain token literals; for example,
⟨\ot\s{ab}~\s{c}~{\it d}~\s{e}\ot⟩ rather than
⟨\ot\s{ab},~\s{c},~{\it d},~\s{e}\ot⟩.

Special terms defined by the specification are set in \term{purple} when they
are first introduced and inline comments are set \comment{after a reference
mark}.
\vskip-\parskip
\bluebox{A blue box is used to describe a convention that clients and engines
are encouraged to follow, usually to do with the interpretation or meaning of
the messages that clients and engines send. A blue box is also used to provide
a recommendation, usually to do with implementation-defined behavior.}
\vskip-\parskip
\greybox{A grey box is used to provide an explanative note or comment.}
\vskip-\parskip
\greenbox{A green box is used to provide an example of conforming behavior.}
\vskip-\parskip
Text within colored boxes is nonnormative.

\major{\bf Definitions}

\minor A \term{violation} is any violation, by the client or engine, of the
requirements of the specification. When a violation occurs, or when the
requirements of the specification are otherwise not met, the specification
imposes no further requirements on the behavior of the client or engine.

% \minor An \term{error} is a condition that should not occur but that is still
% governed by the specification.

\minor The engine's standard input and output must be open file descriptors and
the engine's standard error must be an open file descriptor until closed by the
engine. The sequence of bytes that the client sends to the engine via the
engine's standard input is the \term{client stream}. The sequence of bytes
that the engine sends to the client via the engine's standard output is the
\term{engine stream}.
\vskip-\parskip
\greybox{There are no requirements for an engine's standard error except that
it be open. For example, the engine's standard error may be directed to a null
device, to the client's standard output or standard error, or to a log file.
There are accordingly no restrictions on the sequence of bytes that the engine
writes to its standard error.}
\vskip-\parskip
\bluebox{No particular encoding is specified: the client and engine streams are
not required to be encoded sequences of Unicode scalar values (or code points
of any other character set). The specification instead governs the client and
engine streams as sequences of bytes {\it per se}.\par
However, clients and engines are recommended to use {\caps utf-8} for
client−engine communication so that engine, author, and option names are
displayed properly. Note that clients and engines may use different encodings
for other interfaces, such as for file system paths that are passed as arguments
to the operating system. For example, the client and engine may be communicating
over a network connexion and the client may be running on Linux (where paths
are arbitrary byte sequences that do not contain \hex{00} or \hex{2f}) but the
engine may be running on Windows (where {\caps ntfs} is a common filesystem,
which stores file names in {\caps utf-16}, but where older libraries or
{\caps api}s may expect paths encoded in the local code page), and so the
path of a tablebase file may require transcoding, implicitly or explicitly.}

\minor A \term{message terminator} is the pair ⟨\ot\hex{0d}, \hex{0a}⟩ or
\hex{0a} alone when it is not preceded by \hex{0d}.

\minor Message terminators divide the client and engine streams into
\term{messages}; that is, a message is a (possibly empty) sequence of bytes
that does not contain a message terminator, and every byte of the client and
engine streams is either part of a message or part of a message terminator.
The messages within the client stream are \term{client messages} and the
messages within the engine stream are \term{engine messages}.
\vskip-\parskip
\greybox{This precludes the proper use of some encodings for client−engine
communication, such as \hbox{\caps utf-16} or \hbox{\caps utf-32} (since in
\hbox{\caps utf-16} and \hbox{\caps utf-32}, the byte \hex{0a} appears in the
encodings of various scalar values, whereas in \hbox{\caps utf-8}, the byte
\hex{0a} only appears in the encoding for \uni{000a line feed}).}
\vskip-\parskip
\greybox{Note that \hex{00} is not disallowed.}

\minor The byte \hex{20} divides messages into \term{tokens}, that is, a token
is a non-empty sequence of bytes that are not \hex{20}, and every byte of a
message is either part of a token or is \hex{20}.
\vskip-\parskip
\greybox{In some cases, only the beginning of a message will be viewed as a
collection of tokens and the remainder will be viewed as a contiguous sequence
of bytes.}

\minor For a given sequence of tokens that begin a message (the \term{prefix}),
the \term{suffix} is the contiguous sequence of bytes starting with the first
byte that is not \hex{20} after the prefix and ending with the last byte of the
message.

\minor A sequence of bytes that does not contain any tokens (that is, an empty
sequence or a sequence of one or more repetitions of \hex{20}) is \term{void}.

\minor A \term{position} is a structure with the following fields:

{\leftskip=3ex

\vskip-0.5\parskip An 8×8 array of elements, each of which is either
{\caps none} or a color−\allowbreak kind pair (where the \term{color} is white
or black and the \term{kind} is king, queen, rook, bishop, knight, or pawn).
This array is called the \term{board} and is indexed along one axis by the
letters “a” through “h” inclusive and along the other axis by the numerals
“1” through “8” inclusive. A~color−\allowbreak kind pair is called a
\term{piece}.

\vskip-0.5\parskip A color, white or black, called the \term{side to move}.

\vskip-0.5\parskip A collection of values, called the \term{rights}, which may
be empty or include one or more of the following: the white kingside castling
right, the white queenside castling right, the black kingside castling right,
and the black queenside castling right.

\vskip-0.5\parskip A value called the \term{en passant target}, which is either
{\caps none} or one of a3, b3, \ellipsis\ot, h3, or a6, b6, \ellipsis\ot, h6.

\vskip-0.5\parskip A nonnegative integer called the \term{depth from zeroing}.
\comment{This is the number of moves that have been played (none of which are
captures or pawn moves) since the last capture or pawn move, measured in~ply.}

}

\vskip-0.5\parskip The \term{side waiting} of a position is the opposite color
of the side to move.

\minor For a given position, a king is \term{in check} if it is attacked by one
or more pieces of the opposite color, where “attacked” is defined analogously to
article 3.1.2 of the 2023 {\caps fide} Laws of Chess.

\minor A position is \term{valid} if the following conditions are all satisfied:

{\leftskip=3ex

\vskip-0.5\parskip The board contains exactly one white king and one black king.

\vskip-0.5\parskip The board does not contain any pawns at indices
a1, b1, \ellipsis\ot, h1 and does not contain any pawns at indices
a8, b8, \ellipsis\ot, h8.

\vskip-0.5\parskip If the rights include the white kingside castling right, the
white king is at index e1 and there is a white rook at index h1. If the rights
include the white queenside castling right, the white king is at index e1 and
there is a white rook at index a1. If the rights include the black kingside
castling right, the black king is at index e8 and there is a black rook at
index h8. If the rights include the black queenside castling right, the black
king is at index e8 and there is a black rook at index a8.

\vskip-0.5\parskip If the en passant target is {\it n}\ot3 for some {\it n},
then the side to move is black, there is a white pawn at index {\it n}\ot4,
and at {\it n}\ot2 and {\it n}\ot3 the board is {\caps none}. If the en
passant target is {\it n}\ot6 for some {\it n}, then the side to move is white,
there is a black pawn at index {\it n}\ot5, and at {\it n}\ot6 and {\it n}\ot7
the board is {\caps none}.

\vskip-0.5\parskip The king of the color of the side waiting is not in check.

\vskip-0.5\parskip The depth from zeroing is 100 or less.

\vskip-0.5\parskip There is at least one valid move that can be applied (as
described in \the\majorcount·{\advance\minorcount by 2 \the\minorcount} below).
\comment{This means the position is not checkmate or stalemate.}

}

\vskip-\parskip
\greybox{A valid position (as defined above) need not be reachable from the
starting position.\par
Some engines designed for gameplay rather than analysis may additionally require
that the positions they are sent must be reachable from the starting position.
Such constraints are specific to engines, and are not constraints of the
Universal Chess Interface.}
\vskip-\parskip
\greybox{The 2023 {\caps fide} Laws of Chess state that the game ends
immediately when a player cannot checkmate the king by any series of legal
moves, but this condition does not cause a position to be invalid.}
\vskip-\parskip
\bluebox{Engines are recommended to accept positions that are checkmate or
stalemate even though they are not required to handle receiving such positions.
For such positions, engines should report null as the best move (see
\the\majorcount·{\advance\minorcount by 8 \the\minorcount} below).}

\minor A \term{move} is a structure of three values: a board index called the
\term{source}, a board index called the \term{destination}, and a field
called the \term{promotion kind} that is either {\caps none} or queen, rook,
bishop, or knight.

\minor For a given position {\it P}, a move {\it M} is \term{valid} and the
position {\it Q} \term{immediately follows} when {\it M} is \term{applied} if
{\it P}, {\it M}, and {\it Q} fulfill requirements analogous to articles 3.1
through 3.9 inclusive of the 2023 {\caps fide} Laws of Chess, except

{\leftskip=3ex

\vskip-0.5\parskip the requirement for a pawn to advance by two is instead that
the pawn is white and its index is one of a2, b2, \ellipsis\ot, h2 or that the
pawn is black and its index is one of a7, b7, \ellipsis\ot, h7, and

\vskip-0.5\parskip the requirement for an en passant capture is instead that
the en passant target is not none and the capturing pawn attacks the en passant
target.

}

In particular, when {\it M} is valid, there is a piece of the color of the side
to move in the board of {\it P} at the source of {\it M} and there is a piece
of the same color and kind (or a piece of the same color and the promotion kind
of {\it M}) in the board of {\it Q} at the destination of {\it M}.

The side to move of {\it Q} is the opposite color of the the side to move of
{\it P}. If {\it M} is a king or rook move, the rights of {\it Q} do not include
the corresponding castling right or castling rights. If {\it M} advances a pawn
by two, the en passant target of {\it Q} is the index between the source and
destination of~{\it M}. If {\it M} is a capture or a pawn move, the depth from
zeroing of {\it Q} is zero; otherwise, the depth from zeroing of {\it Q} is the
depth from zeroing of {\it P} plus one.

\def\rjust#1#2{\hbox to #1{\hfil #2}}
\def\alt{\vrule height 7.125pt depth 1.375pt width 0.7pt}

\minor A \term{Forsyth–Edwards Notation ({\caps fen}) record} is a sequence of
six tokens ⟨{\it board, side to move, rights, {\icap ep} target, {\icap dfz},
move number}⟩ of the form\par
%
\dimen0=5em
\vskip-0.5\parskip\hskip3ex\rjust{\dimen0}{\it board}
  \dt=\dt\ \r{(['{\it row}']*8).join('\pt\s/\pt')}\par
\vskip-\parskip\hskip3ex\rjust{\dimen0}{\it row}
  \dt=\dt\ \s8 \alt\ [\s1–\s7\s{KQRBNPkqrbnp}]+\par
\vskip-\parskip\hskip3ex\rjust{\dimen0}{\it side to move}
  \dt=\dt\ \s w \alt\ \s b\par
\vskip-\parskip\hskip3ex\rjust{\dimen0}{\it rights}
  \dt=\dt\ \s- \alt\ \s K?\pt\s Q?\pt\s k?\pt\s q?\par
  % \lower0.5pt\hbox{\notomono ∩} [\s{KQkq}]+)\par
\vskip-\parskip\hskip3ex\rjust{\dimen0}{\it {\icap ep} target}
  \dt=\dt\ \s- \alt\ [\s a–\s h][\s{36}]\par
\vskip-\parskip\hskip3ex\rjust{\dimen0}{\icap dfz}
  \dt=\dt\ \s0 \alt\ [\s1–\s9][\s0–\s9]?\ \alt\ \s{100}\par
\vskip-\parskip\hskip3ex\rjust{\dimen0}{\it move number}
  \dt=\dt\ [\s1–\s9][\s0–\s9]\char"7B\ot0,\pt3\ot\char"7D\par
\vskip-\parskip\hskip3ex
  \comment{The dash “\s-” is \hex{2d}.}

\vskip-0.5\parskip with the following additional constraints:

{\leftskip=3ex

\vskip-0.5\parskip In each {\it row}, numerals must not be adjacent; that is,
there must not be two or more immediately consecutive numerals.

\vskip-0.5\parskip For each {\it row},
map \s K,\pt\s Q, \ellipsis\ot,\pt\s p to 1,
map \s1,\pt\s2, \ellipsis\ot,\pt\s8 to 1,\pt2,\pt\ellipsis,\pt8,
and then define the width as the sum of these numbers.
For each {\it row}, the width must be 8.

}

\minor An {\caps fen} record \term{describes} a position if it maps to the
position in a manner analogous to that described in article 16.1.3 of the
Portable Game Notation Specification.

\minor The \term{starting position} is the position described by the {\caps fen}
record\hfil\penalty-10000
\hbox{\s{rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1}}.

\minor A \term{move token} is a token of the form\par
\vskip-\parskip\hskip3ex
  [\s a–\s h][\s1–\s8][\s a–\s h][\s1–\s8][\s{qrbn}]?\par
\vskip-\parskip The first and second bytes of a move token interpreted in the
natural way as a board index is the move token’s \term{source}, the third and
fourth bytes of a move token interpreted in the natural way as a board index is
the move token’s \term{destination}, and the fifth byte (if present) interpreted
in the natural way as a kind is the \term{promotion kind}. If the fifth byte is
not present, the promotion kind of the move token is {\caps none}.

\minor For a given position {\it P}, a move token {\it T} \term{denotes} a
move {\it M} if {\it M} is valid for {\it P} and the source, destination, and
promotion kind of {\it T} match the source, destination, and promotion kind of
{\it M} (respectively).

\minor A \term{null token} is a token of the form \s{0000}.

\major{\bf Client Messages}

\minor A client message has one of nine types indicated by the first token of
the message (\s{uci}, \s{debug}, \s{setoption}, \s{ucinewgame}, \s{position},
\s{isready}, \s{go}, \s{stop}, and \s{quit}).

\minor A \s{uci}, \s{ucinewgame}, \s{isready}, \s{stop}, or \s{quit} message
is well-formed if it contains exactly one token.

\minor A \s{debug} message is well-formed if it contains exactly two tokens,
either ⟨\ot\s{debug on}\ot⟩ or ⟨\ot\s{debug off}\ot⟩.
\vskip-\parskip
\bluebox{If engines have debugging information to expose via the client
(that is, through standard output rather than standard error), they should
feely send \s{info string} messages with this information after receiving
\s{debug on} and suppress these messages after receiving \s{debug off}.}

% TODO remember to note in the engine section that names and values cannot
%   contain “name” or “value”

\minor A \s{setoption} message is well-formed if it has a prefix of the form
⟨\ot\s{setoption name} {\it tok}\ot\sup+ \s{value}\ot⟩, where {\it tok}\ot\sup+
is one or more tokens matching an option name listed in an \s{option} message
enqueued by the engine, and a suffix satisfying the condition(s) for the
corresponding option type:

{\leftskip=3ex

\vskip-0.5\parskip If \s{check}, the suffix contains exactly one token, either
\s{true} or \s{false}.

\vskip-0.5\parskip If \s{spin}, the suffix contains a single token which is a
decimal integer, either \s0 or of the form
\s–?\pt[\s1–\s9][\s0–\s9]\lower0.25ex\hbox{*}, not less than the minimum value
nor greater than the maximum value specified by the engine.

\vskip-0.5\parskip If \s{combo}, the suffix contains one or more tokens and
the sequence of tokens in the suffix is one of the sequences specified by the
engine.

\vskip-0.5\parskip If \s{string}, the suffix is not void. The suffix \s{<empty>}
indicates an empty value. \comment{The value \s{<empty>} therefore cannot be
specified.}

}

\vskip-0.5\parskip A \s{setoption} message is also well-formed if it is of the
form ⟨\ot\s{setoption name} {\it tok}\ot\sup+\pt⟩ where {\it tok}\ot\sup+ is one
or more tokens matching an option name listed in an \s{option} message enqueued
by the engine for which the corresponding option type is \s{button}.

\minor A \s{position} message is well-formed if it has the form\par
\vskip-\parskip\hskip3ex
⟨\pt\s{position}
  (\ot\s{startpos} \alt\ \s{fen} {\it fen}\ot\sup6\pt)
  (\ot\s{moves} {\it mov}\ot\sup+\ot)?\pt\ot⟩\par
\vskip-\parskip where {\it fen}\ot\sup6 is an {\caps fen} record and
{\it mov}\ot\sup+ is one or more move tokens. If~\s{fen} is specified, the
position described by {\it fen}\ot\sup6 must be valid. Let {\it P}\sub{0} be
the starting position if \s{startpos} is specified and the position described
by {\it fen}\ot\sup6 if \s{fen} is specified. If \s{moves} is specified:

{\leftskip=3ex

\vskip-0.5\parskip Let {\it N} be the number of move tokens specified.

\vskip-0.5\parskip For {\it n} from 0 to {\it N}−1 inclusive, the {\it n}-th
token {\it T}\isub{n} of {\it mov}\ot\sup+ must denote a move {\it M}\isub{n}
from {\it P}\isub{n}. Then let {\it P}\sub{{\subit n}+1} be the position that
immediately follows from {\it P}\isub{n} when {\it M}\isub{n} is applied.

\vskip-0.5\parskip The position {\it P}\isub{N} must be valid.

}

\vskip-0.5\parskip The final position (\ot{\it P}\isub{N} if \s{moves} is
specified, otherwise {\it P}\sub{0}\ot) is the position \term{described} by
the \s{position} message.

% TODO state machine: position message “sets” “current position” to P_N

% TODO engine message: bestmove must be valid move from current position

\minor A \s{go} message is well-formed if\pt\ellipsis

\major{\bf Engine Messages}

An engine message has one of six types indicated by the first token of
the message (\s{id}, \s{option}, \s{uciok}, \s{info}, \s{readyok}, and
\s{bestmove}).

\vfil\break

\major{\bf States and Transitions}

\minor The client and the engine both may always enqueue or dequeue a void
message. When the client or engine dequeues a void message, it must ignore
the message, behaving as if the message were not transmitted.

The remainder of section \the\majorcount\ is written without mention of void
messages; consideration for void messages is tacit.

\minor Once the engine dequeues a \s{uci} message from the client stream,
at every point in time the engine is in one of six \term{states}. The engine
begins in the \term{initial} state. When the engine dequeues a client message
or enqueues an engine message, the state may change; this is a
\term{transition}.
\vskip-\parskip
\greybox{There is a particular invariant that transition rules should satisfy
due to the nature of standard input and standard output.

Firstly, the moment a message is read necessarily occurs some duration after
the moment that the message is written (that is, the sender does not directly
manipulate the memory of the recipient). Secondly, a process cannot both read
from a file descriptor and write to a file descriptor as an atomic transaction
(that is, “time of check to time of use” race conditions cannot be prevented).

In particular, it is impossible for a process to guarantee that a write
to file descriptor {\caps f} is not preceded by a write to file descriptor
{\caps g} by another process. Even if the process attempts to read {\caps g},
finds it empty, and immediately writes to {\caps f}, it is possible for an
intervening write to {\caps g} to occur before the write to {\caps f} occurs.

As a result, if a transition from state {\caps a} to state {\caps b} occurs
when the engine sends a message, it is impossible to guarantee that a message
sent by the client in state {\caps a} can actually be read by the engine in
state {\caps a} (and not in state {\caps b}). Therefore, any message that the
client is allowed to send in state {\caps a} should be allowed in
state~{\caps b}. The same principle holds vice versa, and so we can state the
invariant more generally as follows:

\it For distinct processes 1 and 2, for all pairs of states {\icap a} and
{\icap b}, if a transition from {\icap a} to {\icap b} can be caused by process
1 sending a message, every messages that process 2 is allowed to send in state
{\icap a} must also be allowed in state~{\icap b}.}

\minor In some states, the engine may dequeue a message. If the engine dequeues
a message, the message must be well-formed and have an allowed message type
given the state of the engine.
\vskip-\parskip
\greybox{This is not meant to imply that standard input is ever required to be
empty, but meant to indicate that in some states the engine is not allowed to
read standard input (or at least must behave as if it has not read standard
input).}

\minor In all states, the engine may enqueue a message. If the engine enqueues a
message, the message must be well-formed and have an allowed message type given
the state of the engine.

\minor The allowed message types that may be dequeued and enqueued in each state
are enumerated in the following table. If the {\caps next} column is not empty
for a row, the action listed in the row (dequeuing or enqueuing a message of
a particular type) causes a transition to the listed state.

\dimen0=4em
\dimen1=6em
\dimen2=6em
\dimen3=4em

\dimen4=0em
\advance\dimen4 by \dimen1
\advance\dimen4 by \dimen2

\def\br{\hrule height 0.8pt depth 0pt}
\def\hr{\hrule height 0.4pt depth 0pt}
\def\vr{\vrule width 0.4pt}

\vskip\baselineskip
\hbox to \hsize{%
  \hfil
  \vbox{%
    \br
    \hbox{\strut
         \hbox to \dimen0{\hfil\caps state\hfil}%
      \vr\hbox to \dimen4{\hfil\caps allowed\hfil}%
      \vr\hbox to \dimen3{\hfil\caps next\hfil}%
    }%
    \br
    \hbox{%
      \vtop{%
        \hbox{\strut}%
        \kern 0.4pt\hbox to \dimen0{\strut\hfil initial\hfil}%
      }%
      \vr
      \vtop{
        \hbox{\strut}%
        \kern 0.4pt\hbox to \dimen1{\strut\hfil\caps enqueue\hfil}%
      }%
      \vtop{%
           \hbox to \dimen2{\strut\hem\s{id}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{option}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{uciok}\hfil}%
      }%
      \vr
      \vtop{%
        \hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \hr\hbox to \dimen3{\strut\hfil idle\hfil}%
      }%
    }%
    \br
    \hbox{%
      \vtop{%
        \hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt
        \kern 0.5\strutht\kern 0.5\strutdp
        \kern 0.2pt\hbox to \dimen0{\strut\hfil idle\hfil}%
      }%
      \vr
      \vtop{
        \hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt\hbox to \dimen1{\strut\hfil\caps dequeue\hfil}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \hr\hbox to \dimen1{\strut\hfil\caps enqueue\hfil}%
      }%
      \vtop{%
           \hbox to \dimen2{\strut\hem\s{debug}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{setoption}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{ucinewgame}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{position}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{isready}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{go}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{stop}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{info}\hfil}%
      }%
      \vr
      \vtop{%
        \hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \hr\hbox to \dimen3{\strut\hfil sync\hfil}%
        \hr\hbox to \dimen3{\strut\hfil active\hfil}%
        \hr\hbox{\strut}%
      }%
    }%
    \br
    \hbox{%
      \vtop{%
        \hbox{\strut}%
        \kern -0.5\strutht\kern -0.5\strutdp
        \kern 0.2pt\hbox to \dimen0{\strut\hfil sync\hfil}%
      }%
      \vr
      \vtop{
        \hbox{\strut}%
        \kern -0.5\strutht\kern -0.5\strutdp
        \kern 0.2pt\hbox to \dimen1{\strut\hfil\caps enqueue\hfil}%
      }%
      \vtop{%
           \hbox to \dimen2{\strut\hem\s{info}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{readyok}\hfil}%
      }%
      \vr
      \vtop{%
        \hbox{\strut}%
        \hr\hbox to \dimen3{\strut\hfil idle\hfil}%
      }%
    }%
    \br
    \hbox{%
      \vtop{%
        \hbox{\strut}%
        \kern 0.4pt\hbox{\strut}%
        \kern 0.4pt\hbox to \dimen0{\strut\hfil active\hfil}%
      }%
      \vr
      \vtop{
        \hbox{\strut}%
        \kern 0.4pt\hbox to \dimen1{\strut\hfil\caps dequeue\hfil}%
        \kern 0.4pt\hbox{\strut}%
        \hr
        \kern 0.5\strutht\kern 0.5\strutdp
        \kern 0.2pt\hbox to \dimen1{\strut\hfil\caps enqueue\hfil}%
      }%
      \vtop{%
           \hbox to \dimen2{\strut\hem\s{debug}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{isready}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{stop}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{info}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{bestmove}\hfil}%
      }%
      \vr
      \vtop{%
        \hbox{\strut}%
        \hr\hbox to \dimen3{\strut\hfil ping\hfil}%
        \hr\hbox to \dimen3{\strut\hfil halt\hfil}%
        \hr\hbox{\strut}%
        \hr\hbox to \dimen3{\strut\hfil idle\hfil}%
      }%
    }%
    \br
    \hbox{%
      \vtop{%
        \hbox{\strut}%
        \kern -0.5\strutht\kern -0.5\strutdp
        \kern 0.2pt\hbox to \dimen0{\strut\hfil ping\hfil}%
      }%
      \vr
      \vtop{
        \hbox{\strut}%
        \kern -0.5\strutht\kern -0.5\strutdp
        \kern 0.2pt\hbox to \dimen1{\strut\hfil\caps enqueue\hfil}%
      }%
      \vtop{%
           \hbox to \dimen2{\strut\hem\s{info}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{readyok}\hfil}%
      }%
      \vr
      \vtop{%
        \hbox{\strut}%
        \hr\hbox to \dimen3{\strut\hfil active\hfil}%
      }%
    }%
    \br
    \hbox{%
      \vtop{%
        \hbox{\strut}%
        \kern -0.5\strutht\kern -0.5\strutdp
        \kern 0.2pt\hbox to \dimen0{\strut\hfil halt\hfil}%
      }%
      \vr
      \vtop{
        \hbox{\strut}%
        \kern -0.5\strutht\kern -0.5\strutdp
        \kern 0.2pt\hbox to \dimen1{\strut\hfil\caps enqueue\hfil}%
      }%
      \vtop{%
           \hbox to \dimen2{\strut\hem\s{info}\hfil}%
        \hr\hbox to \dimen2{\strut\hem\s{bestmove}\hfil}%
      }%
      \vr
      \vtop{%
        \hbox{\strut}%
        \hr\hbox to \dimen3{\strut\hfil idle\hfil}%
      }%
    }%
    \br
  }%
  \hfil
}
\vglue-3\baselineskip\vfil\break

\greybox{Engines and clients are not required to ignore (or otherwise handle)
unknown or unexpected tokens (these are simply violations).}

\minor The client must enqueue a \s{ucinewgame} message at least once before
before it enqueues a \s{go} message for the first time after the initial state.
\vskip-\parskip
\bluebox{Engines are strongly recommended to behave identically whether or not
a \s{ucinewgame} message is ever sent.}

\minor The client must enqueue a \s{position} message at least once before it
enqueues a \s{go} message for the first time after the initial state.
\vskip-\parskip
\bluebox{Engines are strongly recommended, if a \s{position} message is not
sent before the first \s{go} message, to behave as if \s{position startpos}
were sent.}
\vskip-\parskip
\greybox{Note that the client is not required to send \s{isready} before
\s{go}.}
\vskip-\parskip
\greybox{Note that the client may send \s{ucinewgame} after \s{position}
before \s{go} without sending any additional intervening \s{position} message.}
\vskip-\parskip
\greybox{Note that \s{ucinewgame} does not reset the current board state nor
does it reset the move history. (Only \s{position} changes the current board
state and move history.)}

\minor The specification ceases to govern the interaction between the client
and the engine when the client enqueues a well-formed \s{quit} message.
\vskip-\parskip
\bluebox{Engines are recommended to stop searching immediately and exit.
Clients are recommended, if engines are their subprocesses, to provide a
grace period before terminating engines.}

% \major{\bf Notation}

\vfil\break

\major{\bf Examples}

\advance\hsize by 10mm

\vskip\parskip
\beginruby
format("let @read_byte! : File_Descriptor -> Byte | EOF")
\endruby

\vskip\parskip
\beginruby
format(%q{
def withoutCR('msg : List(Byte)) : List(Byte)
  if empty?('msg) or last('msg) ≠ `0d then return 'msg
  return withoutLast('msg)
})
\endruby

\vskip\parskip
\beginruby
format(%q{
def read_message!(mut 'fd : File_Descriptor) : List(Byte) | EOF
  'msg <- empty
  repeat
    match read_byte!('fd)
      eof => return (\pt if empty?('msg) then eof else 'msg\pt)
      `0a => return withoutCR('msg)
      'val => append!('msg, 'val\pt)
})
\endruby

\vskip\parskip
\beginruby
format(%q{
def get_token!(mut 'msg : List(Byte)) : List(Byte) | None
  repeat
    if empty?('msg) then return none
    if first('msg) ≠ `20 then break
    removeFirst!('msg)
  'tok <- empty
  repeat
    append!('tok, first('msg))
    removeFirst!('msg)
    if empty?('msg) then return 'tok
    if first('msg) = `20 then break
  return 'tok
})
\endruby

\bye
